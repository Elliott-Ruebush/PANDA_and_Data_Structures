

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;
import java.util.Stack;

/**
 * Handles file reading of the matrix used for Dijkstras and creates an object to run Dijkstras Algorithm on the file
 * that has just been read in. Also handles printing of the matrix and of the final path generated by the algorithm.
 *
 * @author Elliott Ruebush
 */
public class DijkstraProject {

    public static void main(String args[]) {
        System.out.println("Reading in file...");
        try {
            Scanner matrixIn = new Scanner(new BufferedReader(new FileReader("graphs.txt")));
            int size = matrixIn.nextInt();
            Integer[][] matrix = new Integer[size][size];
            //k and i are just reversed since the file is being read in one row at a time
            for (int row = 0; row < size; row++) {
                for (int col = 0; col < size; col++) {
                    matrix[row][col] = matrixIn.nextInt();
                }
            }
            System.out.println("File reading complete.");
            System.out.println("Printing matrix...");
            printArr(matrix);
            //Take user input for start and end nodes
            Scanner userIn = new Scanner(System.in);
            Boolean running = true;
            while (running) {
                System.out.println("\nInput the number of the starting node(-1 will quit)");
                int start = userIn.nextInt();
                if (start == -1) {
                    running = false;
                    break;
                }
                System.out.println("Input the number of the ending node(-1 will quit)");
                int end = userIn.nextInt();
                if (end == -1) {
                    running = false;
                    break;
                }
                ArrayDijkstras PathFinder = new ArrayDijkstras(matrix, start, end);
                ArrayList<Integer> path = PathFinder.runDijkstras();
                printFinalPath(path);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Prints out a two dimensional array
     *
     * @param arr
     */
    public static void printArr(Integer[][] arr) {
        for (Integer[] subArr : arr) {
            for (int k = 0; k < subArr.length; k++) {
                System.out.print(subArr[k] + " ");
            }
            System.out.println();
        }
    }

    /**
     * Prints out the array for the final path ( With arrows included :) )
     *
     * @param path
     */
    public static void printFinalPath(ArrayList<Integer> path) {
        System.out.println("\nPrinting your path...\n");
        for (int i = 0; i < path.size(); i++) {
            if (path.size() - i == 1) {
                System.out.print(path.get(i));
            } else {
                System.out.print(path.get(i) + " -> ");
            }
        }
        System.out.println();
    }


    /**
     * Nested class within the greater DijkstrasProject class with properties and methods for handling array based
     * graphs and implementing Dijkstra's to find shortest paths between points on those graphs
     *
     * @author ruebush.elliott
     */
    private static class ArrayDijkstras {

        Integer[][] matrix;
        int startNode;
        int endNode;
        ArrayList<Integer> unvisited = new ArrayList<>();
        ArrayList<Integer> visited = new ArrayList<>();
        ArrayList<Integer> previous;

        /**
         * Constructor for the array-based Dijkstra class
         *
         * @param matrix
         * @param startNode
         * @param endNode
         */
        public ArrayDijkstras(Integer[][] matrix, int startNode, int endNode) {
            this.matrix = matrix;
            this.startNode = startNode;
            this.endNode = endNode;
        }

        /**
         * Runs Dijkstra's algorithm, finding the shortest path between two nodes on a graph through a system of
         * establishing tentative distances and comparing said distances.
         *
         * @return pathArr
         */
        public ArrayList runDijkstras() {
            //A hashmap isn't necessarily more useful than an arraylist in this situation
            HashMap<Integer, Integer> nodeDistancePairs = new HashMap<>();
            previous = new ArrayList<>(matrix.length);
            visited.add(startNode);
            for (int i = 0; i < matrix.length; i++) {
                unvisited.add(i);
                nodeDistancePairs.put(i, Integer.MAX_VALUE);
                previous.add(i, -1);
            }
            nodeDistancePairs.put(startNode, 0);
            ArrayList<Integer> neighborsArr = new ArrayList<>();
            neighborsArr.add(startNode);
            int currentNode = startNode;
            int tempDist;
            ArrayList<Integer> pathArr = new ArrayList<>();
            while (!(unvisited.isEmpty())) {
                System.out.println("\nUnvisited set: " + unvisited);
                System.out.println("Distance hash map printed: " + nodeDistancePairs.toString());
                System.out.println("Previous printed: " + previous.toString());
                currentNode = lowestDistanceNode(nodeDistancePairs);
                System.out.println("Printing current: " + currentNode);
                visited.add(currentNode);
                unvisited.remove((Integer) currentNode);
                //Check if we've reached the endNode, and if so then we put the final path into an array to be returned
                if(currentNode == endNode){
                    Stack<Integer> pathStack = new Stack<>();
                    int tempCurr = endNode;
                    while(previous.get(tempCurr) != -1){
                        pathStack.push(tempCurr);
                        tempCurr = previous.get(tempCurr);
                    }
                    pathStack.push(tempCurr);
                    pathArr = new ArrayList<>(pathStack.size());
                    while(!(pathStack.isEmpty())){
                        pathArr.add(pathStack.pop());
                    }
                    break;
                }
                neighborsArr = getNeighbors(currentNode);
                System.out.println("Printing neighbors: " + neighborsArr);
                for (Integer neighborNode : neighborsArr) {
                    System.out.println("Neighbornode is: " + neighborNode);
                    tempDist = nodeDistancePairs.get(currentNode) + matrix[neighborNode][currentNode];
                    if (tempDist < nodeDistancePairs.get(neighborNode)) {
                        nodeDistancePairs.put(neighborNode, tempDist);
                        previous.set(neighborNode, currentNode);
                    }

                }

            }

            System.out.println("\n\nPath to be returned: " + pathArr.toString());
            return pathArr;
        }

        /**
         * Iterates through the list of distances in order to find out which node has the lowest current distance value
         * and return the id of that node
         *
         * @param distances
         * @return closest
         */
        public Integer lowestDistanceNode(HashMap distances) {
            int closest = Integer.MAX_VALUE;
            for(Integer unvisitedNode : unvisited){
                if((int) distances.get(unvisitedNode) < closest){
                    closest = unvisitedNode;
                }
            }
            return closest;
        }

        /**
         * Returns an array with all unvisited neighbors of a specified node
         *
         * @param current
         * @return neighborsArr
         */
        public ArrayList<Integer> getNeighbors(int current) {
            ArrayList<Integer> neighbors = new ArrayList<>();
            for (int nodeId = 0; nodeId < matrix.length; nodeId++) {
                if (matrix[nodeId][current] > 0 && unvisited.contains(nodeId)) {
                    neighbors.add(nodeId);
                }
            }
            return neighbors;
        }
    }
}